import functools
import json
import os
import re
import urllib
from base64 import b64decode
from datetime import datetime, timedelta
from urllib.parse import parse_qs

import rsa
import structlog
from boto3.dynamodb.conditions import Key
from botocore.exceptions import ClientError
from botocore.signers import CloudFrontSigner

from . import params
from .util.log_config import setup_logging


class CloudFrontUtil:
    """
    Generate signed URLs or cookies for AWS CloudFront.

    from [AWS CloudFront generate signed urls and cookies with Python and Golang](https://gist.github.com/zhangwm404/f532475f394c1b14f0e33ef047f78e05#python-code)
    """

    def __init__(self, private_key_path: str, key_id: str):
        """
        :param private_key_path: str, the path of private key which generated by openssl command line
        :param key_id: str, CloudFront -> Key management -> Public keys
        """
        self.key_id = key_id

        with open(private_key_path, "rb") as fp:
            priv_key = rsa.PrivateKey.load_pkcs1(fp.read())

        # NOTE: CloudFront use RSA-SHA1 for signing URLs or cookies
        self.rsa_signer = functools.partial(
            rsa.sign, priv_key=priv_key, hash_method="SHA-1"
        )
        self.cf_signer = CloudFrontSigner(key_id, self.rsa_signer)

    def generate_presigned_url(self, url: str, expire_at: datetime) -> str:
        # Create a signed url that will be valid until the specfic expiry date
        # provided using a canned policy.
        return self.cf_signer.generate_presigned_url(url, date_less_than=expire_at)

    def generate_signed_cookies(self, url: str, expire_at: datetime) -> str:
        policy = self.cf_signer.build_policy(url, expire_at).encode("utf8")
        policy_64 = self.cf_signer._url_b64encode(policy).decode("utf8")

        signature = self.rsa_signer(policy)
        signature_64 = self.cf_signer._url_b64encode(signature).decode("utf8")
        return {
            "CloudFrontPolicy": policy_64,
            "CloudFrontSignature": signature_64,
            "CloudFrontKeyPairId": self.key_id,
        }


extract_recording_path_RE = re.compile("https://[^/]+/(.*?)(/|/index\.html)?$")


def response_wrap(content=None, error=None, statusCode=200):
    """
    Generate an API Gateway response for Lambda
    https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-lambda.html#http-api-develop-integrations-lambda.response

    :param content: Text fragment to be returned
    :param statusCode: HTTP response status code (default=200)

    :return: AWS HTTP API Lambda Response dictionary
    """
    response = {
        "statusCode": statusCode,
        "headers": {},
    }
    if error:
        response["headers"]["content-type"] = "application/json"
        response["body"] = json.dumps({"error": error})
    else:
        response["headers"]["content-type"] = "text/plain"
        response["body"] = content
    return response


def handler(event, context):
    setup_logging()
    aws_request_id = "*NO CONTEXT*" if context is None else context.aws_request_id
    params.log = structlog.get_logger()
    params.log = params.log.bind(aws_request_id=aws_request_id)
    params.log.info("STARTED", http_event=event)

    ##STAGE Read form content
    stage = "Read form content"
    if "body" in event:
        body = event["body"]
    else:
        params.log.warn(stage, reason="No body content", http_event=event)
        return response_wrap(
            error="The form submission did not include a the required data. Please try again.",
            statusCode=400,
        )

    if "isBase64Encoded" in event and event["isBase64Encoded"]:
        body = b64decode(body)
    if event["headers"]["content-type"] == "application/json":
        body = json.loads(body)
    elif event["headers"]["content-type"] == "application/x-www-form-urlencoded":
        body = parse_qs(body.decode())
    params.log.debug(stage, reason="Received body content", body=body)

    if (current_page := body.get("current_page")) is None:
        params.log.warn(stage, reason="No current_page URL parameter", event=event)
        return response_wrap(
            error="The form submission did not include a current_page URL. Please try again.",
            statusCode=500,
        )

    ##STAGE Look up meeting
    stage = "Look up meeting"
    extract_recording_path_match = extract_recording_path_RE.match(current_page)
    if (recording_path := extract_recording_path_match.group(1)) is None:
        params.log.warn(stage, reason="recording_path regex not found", event=event)
        return response_wrap(
            error=f"The form submission didn't include a valid page. This should not happen. {aws_request_id=}",
            statusCode=500,
        )

    response = params.meetings_table.scan(
        IndexName="path-index",
        Select="ALL_PROJECTED_ATTRIBUTES",
        FilterExpression=Key("recording_path").eq(recording_path),
    )
    params.log.debug(
        stage,
        reason="Retrieved results",
        recording_path=recording_path,
        response=response,
    )
    try:
        meetings = response["Items"]
    except BaseException as err:
        params.log.error(stage, "Invalid response", exception=err, response=response)
        return response_wrap(
            error=f"AWS returned bad info. This should not happen. {aws_request_id=}",
            statusCode=500,
        )
    if not meetings:
        params.log.warn(
            stage,
            reason="NONE FOUND",
            get_item_response=response,
            recording_path=recording_path,
        )
        return response_wrap(
            error=f"This meeting could not be found. This should not happen. {aws_request_id=}",
            statusCode=500,
        )
    if len(meetings) > 1:
        params.log.error(stage, reason="TOO MANY FOUND", get_item_response=response)
        return response_wrap(
            error=f"Too many meetings found in database. This should not happen. {aws_request_id=}",
            statusCode=500,
        )

    if (meeting_password := meetings[0].get("password")) is not None:
        ## The meeting has a password; see if we got a password string from the form
        if "password" not in body:
            params.log.warn(stage, reason="No password parameter", http_event=event)
            return response_wrap(
                error="The form submission did not include a password. Please try again.",
                statusCode=400,
            )
        if meeting_password != body["password"]:
            params.log.info(
                stage,
                reason="Password mismatch",
                meeting_password=meeting_password,
                body_password=body["password"],
            )
            return response_wrap(
                error="Incorrect password. Please try again.",
                statusCode=400,
            )

    ##STAGE Get signed cookies
    stage = "Get signed cookies"
    private_key_path = f"{os.environ['LAMBDA_TASK_ROOT']}/keys/private_key.pem"
    key_id = os.environ["PUBLIC_KEY_ID"]
    url = f'https://{os.environ["HOSTNAME"]}/{recording_path}*'
    expire_at = datetime.now() + timedelta(days=1)

    cfu = CloudFrontUtil(private_key_path, key_id)

    signed_cookies = cfu.generate_signed_cookies(url, expire_at)
    params.log.debug(stage, reason="Signed cookies", signed_cookies=signed_cookies)

    ##STAGE Generate Response
    stage = "Generate response"
    response = json.dumps(signed_cookies, indent=4)
    params.log.debug(stage, reason="Generated response", response=response)
    return response
